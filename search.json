[{"title":"03-cookie、session","path":"/2023/04/09/03-cookie、session/","content":"cookie、session会话会话：用户打开浏览器，点了很多超链接，访问多个web资源，关闭浏览器这个过程称之为会话 有状态会话：一个同学来过教室，下次再来教室，我们知道他曾经来过。 保存会话的两种技术cookie客户端技术(响应，请求) session服务器技术，利用这个技术可以保存用户的会话信息，我们可以把信息或数据保存到session中。 cookie 从请求中拿到cookie信息 服务器响应给客户端cookie 12345678910111213141516171819202122232425@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(&quot;utf-8&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); Cookie[] cookies = req.getCookies(); int flag=-1; for (int i = 0; i &lt; cookies.length; i++) &#123; if (cookies[i].getName().equals(&quot;loginTime&quot;))&#123; flag=i; break; &#125; &#125; if (flag!=-1)&#123; long loginTime = Long.parseLong(cookies[flag].getValue()); Date date = new Date(loginTime); System.out.println(date.toLocaleString()); &#125;else &#123; System.out.println(&quot;欢迎您首次到来！&quot;); &#125; //每次登录网站都会更新时间 Cookie loginTime = new Cookie(&quot;loginTime&quot;, System.currentTimeMillis() + &quot;&quot;); //给cookie设置一个有效期 loginTime.setMaxAge(24*60*60); resp.addCookie(loginTime); &#125; cookie存在上限 一个cookie只能保存一个信息 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie cookie站点有限制大小为4kb 浏览器上限300个cookie 删除cookie不设置有效期，关闭浏览器，自动失效 设置有效期为0 编码解码12URLEncoder.encode(&quot;中文&quot;,&quot;utf-8&quot;);URLDecoder.decode(cookies[0].getValue(),&quot;utf-8&quot;); session 介绍 服务器会给每一个用户(浏览器)创建一个session对象 一个session独占一个浏览器，只要浏览器没关闭，这个session就存在 用户登陆之后整个网站都可以访问 –&gt;保存用户的信息 1234567891011121314151617181920@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //解决乱码问题 req.setCharacterEncoding(&quot;utf-8&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); resp.setContentType(&quot;text/html;charset=utf-8&quot;); //得到session HttpSession session = req.getSession(); //得到sessionId String id = session.getId(); //在session中存储属性 session.setAttribute(&quot;name&quot;,&quot;小黑子&quot;); if (session.isNew())&#123; resp.getWriter().write(id+&quot;创建成功！&quot;); &#125;else&#123; resp.getWriter().write(session.getAttribute(&quot;name&quot;)+&quot;属性设置成功！&quot;); &#125; //手动注销session session.invalidate(); &#125; 设置session有效日期1234&lt;session-config&gt;&lt;!-- 以分钟为单位--&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; session和cookie的区别 cookie是把用户的数据写给用户的浏览器，浏览器保存(可以保存多个) session是把用户的数据写到用户独占session中，服务端保存(保存重要的资源，减少服务器资源的浪费) session对象是由服务端创建的","tags":["java-web"]},{"title":"02-servlet","path":"/2023/04/09/02-servlet/","content":"servlet简介 servlet是sun公司开发动态web的一门技术 sun公司在这些API提供一个接口叫做servlet，如果你想完成一个servlet应用程序，只需两个步骤 编写一个类，实现servlet接口 把开发好的java类部署到web服务器中 基本原理示意图 mapping一个servlet可以指定一个或多个映射路径 一个servlet可指定一些后缀或者前缀 制定了固有的映射路径优先级最高，如果找不到就会走默认的请求路径。 servlet contextweb容器在启动的时候，它会为每个web程序都创建一个servletcontext对象，它代表了当前的web应用。 共享数据我在这个servlet保存的数据可以在另外一个servlet中拿到 代码123456789101112131415//servlet01public class servlet_context_01 extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req,resp); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String username=&quot;阳光开朗大男孩&quot;; ServletContext context=this.getServletContext(); context.setAttribute(&quot;username&quot;,username); &#125;&#125; 示意图 获取初始化参数配置代码1234&lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306?mybatis&lt;/param-value&gt; &lt;/context-param&gt; 请求转发 读取资源文件properties 在Java目录下，新建properties 在resources目录下新建properties 发现，都被打包到了同一个路径下：classes，我们俗称这个路径为classpath 123456789101112131415161718192021//xml配置文件&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 四种功能代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243package com.XZY_SUNSHINE.context;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class servlet_context_02 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext servletContext = this.getServletContext();// String username=(String)(servletContext.getAttribute(&quot;username&quot;));// String url=servletContext.getInitParameter(&quot;url&quot;);// resp.getWriter().println(username);//共享数据// resp.getWriter().println(url);//获取初始化参数// try &#123;// Thread.sleep(1000);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// //请求转发// servletContext.getRequestDispatcher(&quot;/&quot;).forward(req,resp); //读取资源文件 InputStream resourceAsStream = servletContext.getResourceAsStream(&quot;/WEB-INF/classes/com/XZY_SUNSHINE/context/a.properties&quot;); Properties properties = new Properties(); properties.load(resourceAsStream); String username1 = properties.getProperty(&quot;username&quot;); System.out.println(username1); resp.getWriter().println(username1); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; HttpServletResponseweb服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse 如果要获取客户端请求过来的参数:找HttpServletRequest 如果要给客户端响应一些信息：找HttpServletResponse 分类向浏览器发送数据的方法12ServletOutputStream getOutputStream() throws IOException;PrintWriter getWriter() throws IOException; 向浏览器发送响应头的方法1234567891011void setDateHeader(String var1, long var2);void addDateHeader(String var1, long var2);void setHeader(String var1, String var2);void addHeader(String var1, String var2);void setIntHeader(String var1, int var2);void addIntHeader(String var1, int var2); 响应的状态码1234567891011121314151617181920212223242526272829303132333435363738394041int SC_CONTINUE = 100;int SC_SWITCHING_PROTOCOLS = 101;int SC_OK = 200;int SC_CREATED = 201;int SC_ACCEPTED = 202;int SC_NON_AUTHORITATIVE_INFORMATION = 203;int SC_NO_CONTENT = 204;int SC_RESET_CONTENT = 205;int SC_PARTIAL_CONTENT = 206;int SC_MULTIPLE_CHOICES = 300;int SC_MOVED_PERMANENTLY = 301;int SC_MOVED_TEMPORARILY = 302;int SC_FOUND = 302;int SC_SEE_OTHER = 303;int SC_NOT_MODIFIED = 304;int SC_USE_PROXY = 305;int SC_TEMPORARY_REDIRECT = 307;int SC_BAD_REQUEST = 400;int SC_UNAUTHORIZED = 401;int SC_PAYMENT_REQUIRED = 402;int SC_FORBIDDEN = 403;int SC_NOT_FOUND = 404;int SC_METHOD_NOT_ALLOWED = 405;int SC_NOT_ACCEPTABLE = 406;int SC_PROXY_AUTHENTICATION_REQUIRED = 407;int SC_REQUEST_TIMEOUT = 408;int SC_CONFLICT = 409;int SC_GONE = 410;int SC_LENGTH_REQUIRED = 411;int SC_PRECONDITION_FAILED = 412;int SC_REQUEST_ENTITY_TOO_LARGE = 413;int SC_REQUEST_URI_TOO_LONG = 414;int SC_UNSUPPORTED_MEDIA_TYPE = 415;int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;int SC_EXPECTATION_FAILED = 417;int SC_INTERNAL_SERVER_ERROR = 500;int SC_NOT_IMPLEMENTED = 501;int SC_BAD_GATEWAY = 502;int SC_SERVICE_UNAVAILABLE = 503;int SC_GATEWAY_TIMEOUT = 504;int SC_HTTP_VERSION_NOT_SUPPORTED = 505; 常见应用向浏览器输出信息下载文件 要获取下载文件的路径 获取下载的文件名 设置浏览器能够支持我们下载的东西 获取下载文件的输入流 创建缓冲区 获取outputsream对象 将fileinputstream流写入到buffer缓冲区，使用outputstream将缓冲区的数据输出到客户端 1234567891011121314151617181920212223242526@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取文件路径 String realPath = &quot;E:\\\\自学路线\\\\代码\\\\com.XZY_SUNSHINE\\\\servlet_context_demo2\\\\src\\\\main\\\\resources\\\\ASCII码对照表.png&quot;; System.out.println(realPath);// E:\\自学路线\\代码\\com.XZY_SUNSHINE\\servlet_context_demo2\\src\\main\\resources\\ASCII码对照表.png //获取文件名 String FileName = realPath.substring(realPath.lastIndexOf(&quot;\\\\&quot;) + 1); //设置想办法让浏览器能够支持下载我们需要的东西 System.out.println(FileName); resp.setHeader(&quot;Content-disposition&quot;,&quot;attachment;filename=&quot;+ URLEncoder.encode(FileName,&quot;utf-8&quot;)); //获取文件的输入流 FileInputStream fileInputStream = new FileInputStream(realPath); //创建缓冲区 int length=0; byte[] bytes = new byte[1024]; //获取输出流对象 ServletOutputStream outputStream = resp.getOutputStream(); //下载文件 while((length=fileInputStream.read(bytes))&gt;0)&#123; outputStream.write(bytes,0,length); &#125; //关闭资源 fileInputStream.close(); outputStream.close(); &#125; 验证码功能 让浏览器自动刷新。 写一个生成验证码的函数 画图 告诉浏览器用图片的方式打开 设置参数使得浏览器无法缓存 1234567891011121314151617181920212223242526272829303132333435@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //让浏览器五秒刷新一次 resp.setHeader(&quot;refresh&quot;,&quot;5&quot;); //在内存创建一个图片 BufferedImage bufferedImage = new BufferedImage(200,100,BufferedImage.TYPE_INT_RGB); //得到画笔 Graphics2D graphics =(Graphics2D) bufferedImage.getGraphics(); graphics.setColor(Color.white); graphics.fillRect(0,0,200,100); //生成随机数 String nums=get_nums(); //将随机数画在画板上 graphics.setColor(Color.BLUE); graphics.drawString(nums,100,50); //告诉浏览器，图片的方式打开 resp.setContentType(&quot;image/png&quot;); //设置为不缓存 resp.setDateHeader(&quot;expires&quot;,-1); resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;); resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);// 把图片写给浏览器 ImageIO.write(bufferedImage,&quot;png&quot;,resp.getOutputStream()); &#125; public String get_nums()&#123; String nums=null; Random random = new Random(); nums = random.nextInt(99999)+&quot;&quot;; StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i &lt; 5-nums.length(); i++) &#123; stringBuffer.append(i); &#125; nums=nums+stringBuffer.toString(); return nums; &#125; 实现重定向 一个web资源收到客户端请求后，他会通知客户端去访问另一个web资源，这个过程叫做重定向。 123456@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;// resp.sendRedirect(&quot;/s2/get_image&quot;); resp.setHeader(&quot;location&quot;,&quot;/s2/get_image&quot;); resp.setStatus(302); &#125; 重定向和转发的区别： 相同点：页面都会实现跳转 不同点：请求转发的时候，url不会发生变化。重定向url会发生变化 HttpServletRequestHttpServletRequest代表客户端的请求，用户通过http协议访问服务器，http请求中的所有的信息会被封装到HttpServletRequest 获取前端传递的参数 请求转发","tags":["java-web"]},{"title":"git","path":"/2023/04/09/git/","content":"Git简介Git是分布式控制系统，用来处理项目。 版本控制版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。它最重要的是可以记录文件修改历史纪录，从而让用户能够查看历史版本，方便版本切换。 版本控制工具集中式版本控制工具集中化的版本控制系统诸如CVS、SVN等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 分布式控制系统客户端提取的不是最新版本的文件快照，二是把代码仓库完整的镜像下来，这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为客户端的每一次文件提取操作，实际上都是对整个文件仓库的完整备份。 工作机制 代码托管中心代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为远程库。 常用命令 说明签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git首次安装必须设置一次用户签名，否则无法提交代码。这里设置用户签名和将来登录Github的账号没有任何关系。 分支什么是分支在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。 分支操作 合并冲突合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。git无法替我们决定使用哪一个，必须认为决定新代码的内容。 解决合并错误出现后，vim打开要合并的文件，将自己不想要保存的代码删掉，保存退出。然后，保存至暂存区，最后提交，提交的时候就不要带文件名了。 远程仓库 SSH免密登录 Idea集成忽略文件git.ignore123456789101112131415161718192021222324252627# Compiled class file*.class# Log file*.log# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*.classpath.project.settingstarget.idea*.iml git.config12[core]excludesfile = C:/Users/asus/git.ignore","tags":["git"]}]